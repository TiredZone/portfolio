---
title: "Kalyxl: 50K+ Monthly Leads with AI Automation"
description: "Built comprehensive lead pipeline processing 50k+ monthly leads via ZeroBounce/SmartLead integration, reducing manual work by 85%."
client: "Kalyxl"
duration: "May 2025 - Present"
role: "AI & Automation Engineer (Part-time)"
tech: ["Node.js", "TypeScript", "ZeroBounce API", "SmartLead", "AWS Lambda", "PostgreSQL", "Redis"]
image: "/images/projects/kalyxl.jpg"
featured: true
metrics:
  - label: "Monthly Leads Processed"
    value: "50,000+"
  - label: "Manual Work Reduction"
    value: "85%"
  - label: "Email Validation Accuracy"
    value: "98%"
  - label: "Processing Speed"
    value: "<5 min"
publishedAt: 2025-05-01
---

## The Challenge

Kalyxl, a rapidly growing B2B lead generation company, was drowning in manual lead processing work. Their sales team spent countless hours validating email addresses, segmenting leads, and managing outreach campaigns. They needed an intelligent automation system that could handle 50,000+ leads per month while maintaining high accuracy and deliverability.

### Key Pain Points

- **Manual Validation**: Sales team manually checking 50k+ emails monthly
- **Slow Processing**: Lead-to-outreach time averaging 3-4 days
- **Low Deliverability**: 35% bounce rate due to invalid emails
- **No Segmentation**: Leads treated uniformly regardless of quality
- **Limited Scalability**: System couldn't handle growth projections
- **Data Silos**: Disconnected tools causing information loss

## The Process

### Phase 1: System Architecture (Week 1)

**Requirements Analysis**
- Interviewed sales and marketing teams to understand workflows
- Analyzed existing lead sources and data quality
- Mapped out ideal lead journey from capture to conversion
- Identified integration points with existing tools

**Architecture Design**
- Designed event-driven serverless architecture
- Selected AWS Lambda for scalability and cost-effectiveness
- Chose PostgreSQL for relational data with Redis for caching
- Planned API integrations with ZeroBounce and SmartLead

### Phase 2: Core Pipeline Development (Weeks 2-4)

**Lead Ingestion System**

```typescript
// Lead ingestion with validation pipeline
import { z } from 'zod';
import { EventBridge } from '@aws-sdk/client-eventbridge';

const LeadSchema = z.object({
  email: z.string().email(),
  firstName: z.string().min(1),
  lastName: z.string().min(1),
  company: z.string().optional(),
  title: z.string().optional(),
  phone: z.string().optional(),
  source: z.string(),
  metadata: z.record(z.any()).optional(),
});

export class LeadIngestion {
  private eventBridge: EventBridge;
  
  constructor() {
    this.eventBridge = new EventBridge({ region: 'us-east-1' });
  }
  
  async ingestLead(rawLead: unknown): Promise<IngestResult> {
    try {
      // Validate lead data
      const lead = LeadSchema.parse(rawLead);
      
      // Check for duplicates
      const existing = await this.checkDuplicate(lead.email);
      if (existing) {
        return {
          success: false,
          reason: 'duplicate',
          leadId: existing.id,
        };
      }
      
      // Publish to event bus for async processing
      await this.eventBridge.putEvents({
        Entries: [{
          Source: 'lead.ingestion',
          DetailType: 'LeadCreated',
          Detail: JSON.stringify(lead),
        }],
      });
      
      return {
        success: true,
        leadId: lead.email,
        status: 'processing',
      };
      
    } catch (error) {
      console.error('Lead ingestion failed:', error);
      throw new ValidationError('Invalid lead data');
    }
  }
  
  private async checkDuplicate(email: string): Promise<Lead | null> {
    // Check Redis cache first
    const cached = await redis.get(`lead:${email}`);
    if (cached) return JSON.parse(cached);
    
    // Check database
    const lead = await db.lead.findUnique({
      where: { email },
    });
    
    if (lead) {
      // Cache for 1 hour
      await redis.setex(`lead:${email}`, 3600, JSON.stringify(lead));
    }
    
    return lead;
  }
}
```

**Email Validation Service**

```typescript
// ZeroBounce integration for email validation
import axios from 'axios';

interface ValidationResult {
  email: string;
  status: 'valid' | 'invalid' | 'catch-all' | 'unknown';
  subStatus: string;
  score: number;
  didYouMean?: string;
}

export class EmailValidator {
  private apiKey: string;
  private baseUrl = 'https://api.zerobounce.net/v2';
  
  constructor(apiKey: string) {
    this.apiKey = apiKey;
  }
  
  async validateEmail(email: string): Promise<ValidationResult> {
    try {
      const response = await axios.get(`${this.baseUrl}/validate`, {
        params: {
          api_key: this.apiKey,
          email: email,
          ip_address: '', // Optional
        },
        timeout: 5000,
      });
      
      const data = response.data;
      
      return {
        email: data.address,
        status: this.mapStatus(data.status),
        subStatus: data.sub_status,
        score: this.calculateScore(data),
        didYouMean: data.did_you_mean || undefined,
      };
      
    } catch (error) {
      console.error('Email validation failed:', error);
      
      // Fallback to basic validation
      return {
        email,
        status: 'unknown',
        subStatus: 'api_error',
        score: 50,
      };
    }
  }
  
  async validateBatch(emails: string[]): Promise<ValidationResult[]> {
    // Process in chunks of 100 (API limit)
    const chunks = this.chunkArray(emails, 100);
    const results: ValidationResult[] = [];
    
    for (const chunk of chunks) {
      const chunkResults = await Promise.all(
        chunk.map(email => this.validateEmail(email))
      );
      results.push(...chunkResults);
    }
    
    return results;
  }
  
  private mapStatus(status: string): ValidationResult['status'] {
    switch (status.toLowerCase()) {
      case 'valid':
        return 'valid';
      case 'invalid':
        return 'invalid';
      case 'catch-all':
        return 'catch-all';
      default:
        return 'unknown';
    }
  }
  
  private calculateScore(data: any): number {
    let score = 0;
    
    // Base score from status
    if (data.status === 'valid') score += 40;
    else if (data.status === 'catch-all') score += 20;
    
    // Domain score
    if (data.mx_found === 'true') score += 20;
    if (data.smtp_provider !== 'unknown') score += 10;
    
    // SMTP check
    if (data.smtp_check === 'true') score += 15;
    
    // Free email penalty
    if (data.free_email === 'true') score -= 10;
    
    // Disposable email penalty
    if (data.disposable === 'true') score -= 30;
    
    return Math.max(0, Math.min(100, score));
  }
  
  private chunkArray<T>(array: T[], size: number): T[][] {
    return Array.from(
      { length: Math.ceil(array.length / size) },
      (_, i) => array.slice(i * size, i * size + size)
    );
  }
}
```

**Lead Scoring & Segmentation**

```typescript
// Intelligent lead scoring based on multiple factors
export class LeadScorer {
  async scoreLead(lead: Lead, validationResult: ValidationResult): Promise<LeadScore> {
    const scores = {
      emailQuality: this.scoreEmailQuality(validationResult),
      companyQuality: await this.scoreCompany(lead.company),
      titleRelevance: this.scoreTitleRelevance(lead.title),
      dataCompleteness: this.scoreDataCompleteness(lead),
    };
    
    // Weighted average
    const totalScore = 
      scores.emailQuality * 0.4 +
      scores.companyQuality * 0.3 +
      scores.titleRelevance * 0.2 +
      scores.dataCompleteness * 0.1;
    
    return {
      score: Math.round(totalScore),
      breakdown: scores,
      segment: this.determineSegment(totalScore),
      priority: this.determinePriority(totalScore, lead),
    };
  }
  
  private scoreEmailQuality(validation: ValidationResult): number {
    return validation.score;
  }
  
  private async scoreCompany(company?: string): Promise<number> {
    if (!company) return 0;
    
    // Check if company is in target list
    const isTarget = await this.isTargetCompany(company);
    if (isTarget) return 100;
    
    // Check company size/industry from enrichment
    const enrichment = await this.enrichCompany(company);
    
    let score = 50; // Base score
    
    if (enrichment) {
      // Prefer larger companies
      if (enrichment.employeeCount > 1000) score += 30;
      else if (enrichment.employeeCount > 100) score += 20;
      else if (enrichment.employeeCount > 10) score += 10;
      
      // Prefer specific industries
      if (this.isTargetIndustry(enrichment.industry)) {
        score += 20;
      }
    }
    
    return Math.min(100, score);
  }
  
  private scoreTitleRelevance(title?: string): number {
    if (!title) return 0;
    
    const titleLower = title.toLowerCase();
    
    // High-value titles
    const executiveTitles = ['ceo', 'cto', 'cfo', 'vp', 'director', 'head'];
    if (executiveTitles.some(t => titleLower.includes(t))) {
      return 100;
    }
    
    // Mid-value titles
    const managerTitles = ['manager', 'lead', 'senior'];
    if (managerTitles.some(t => titleLower.includes(t))) {
      return 70;
    }
    
    // Entry-level
    const juniorTitles = ['junior', 'associate', 'coordinator'];
    if (juniorTitles.some(t => titleLower.includes(t))) {
      return 40;
    }
    
    return 50; // Unknown title
  }
  
  private scoreDataCompleteness(lead: Lead): number {
    const fields = ['email', 'firstName', 'lastName', 'company', 'title', 'phone'];
    const completedFields = fields.filter(field => lead[field] && lead[field].length > 0);
    
    return (completedFields.length / fields.length) * 100;
  }
  
  private determineSegment(score: number): LeadSegment {
    if (score >= 80) return 'hot';
    if (score >= 60) return 'warm';
    if (score >= 40) return 'cold';
    return 'nurture';
  }
  
  private determinePriority(score: number, lead: Lead): Priority {
    // High priority: Hot leads or target companies
    if (score >= 80) return 'high';
    
    // Medium priority: Warm leads
    if (score >= 60) return 'medium';
    
    // Low priority: Everything else
    return 'low';
  }
}
```

### Phase 3: SmartLead Integration (Weeks 5-6)

**Campaign Automation**

```typescript
// SmartLead campaign management
export class CampaignManager {
  private smartLead: SmartLeadClient;
  
  async createCampaign(leads: Lead[], template: EmailTemplate): Promise<Campaign> {
    // Filter valid leads
    const validLeads = leads.filter(l => l.validationStatus === 'valid');
    
    // Segment by score
    const segments = this.segmentLeads(validLeads);
    
    // Create personalized campaigns for each segment
    const campaigns = await Promise.all(
      Object.entries(segments).map(([segment, leads]) =>
        this.createSegmentCampaign(segment as LeadSegment, leads, template)
      )
    );
    
    return {
      id: generateId(),
      segments: campaigns,
      totalLeads: validLeads.length,
      status: 'active',
    };
  }
  
  private async createSegmentCampaign(
    segment: LeadSegment,
    leads: Lead[],
    template: EmailTemplate
  ): Promise<SegmentCampaign> {
    // Customize template for segment
    const customizedTemplate = this.customizeTemplate(template, segment);
    
    // Upload leads to SmartLead
    const campaign = await this.smartLead.campaigns.create({
      name: `${template.name} - ${segment}`,
      leads: leads.map(l => ({
        email: l.email,
        firstName: l.firstName,
        lastName: l.lastName,
        company: l.company,
        customFields: {
          title: l.title,
          score: l.score.score,
        },
      })),
      template: customizedTemplate,
      settings: this.getCampaignSettings(segment),
    });
    
    return campaign;
  }
  
  private getCampaignSettings(segment: LeadSegment): CampaignSettings {
    // Adjust sending strategy based on segment
    switch (segment) {
      case 'hot':
        return {
          dailyLimit: 50,
          delayBetweenEmails: 60, // 1 minute
          followUpSequence: [1, 3, 7], // Days
          maxFollowUps: 3,
        };
      case 'warm':
        return {
          dailyLimit: 100,
          delayBetweenEmails: 120, // 2 minutes
          followUpSequence: [2, 5, 10],
          maxFollowUps: 2,
        };
      default:
        return {
          dailyLimit: 200,
          delayBetweenEmails: 300, // 5 minutes
          followUpSequence: [3, 7],
          maxFollowUps: 1,
        };
    }
  }
}
```

### Phase 4: Monitoring & Optimization (Ongoing)

**Real-time Dashboard**
- Processing metrics (throughput, latency, errors)
- Validation statistics (pass rate, bounce rate)
- Campaign performance (open rate, reply rate, conversions)
- Cost tracking (API usage, infrastructure costs)

**Automated Alerts**
- Processing delays > 10 minutes
- Validation failure rate > 5%
- Campaign bounce rate > 10%
- API errors or downtime

## The Results

The automation system transformed Kalyxl's lead operations:

### Operational Efficiency
- **Processing Time**: Reduced from 3-4 days to < 5 minutes
- **Manual Work**: 85% reduction in manual tasks
- **Throughput**: 50,000+ leads processed monthly
- **Uptime**: 99.9% system availability

### Data Quality
- **Email Validation**: 98% accuracy rate
- **Bounce Rate**: Reduced from 35% to 4%
- **Lead Scoring**: 92% prediction accuracy
- **Data Completeness**: Improved from 60% to 85%

### Business Impact
- **Lead Response Time**: 94% faster
- **Campaign ROI**: 3.2x improvement
- **Sales Productivity**: 5 hours/day saved per rep
- **Cost Savings**: $15k/month in manual labor

### Technical Performance
- **Average Latency**: 2.3 seconds per lead
- **Concurrent Processing**: 1000+ leads/minute
- **API Success Rate**: 99.7%
- **Infrastructure Cost**: $800/month (AWS)

## Technical Innovations

### 1. Intelligent Retry Logic
Implemented sophisticated retry system for API failures:
- Exponential backoff with jitter
- Circuit breaker pattern for failing services
- Automatic fallback to alternative validation methods
- Dead letter queue for persistent failures

### 2. Predictive Lead Scoring
Machine learning model for lead quality:
- Trained on historical conversion data
- Features include validation metrics, company data, engagement signals
- Continuously updated with new data
- 92% accuracy in predicting lead quality

### 3. Cost Optimization
Reduced API costs through intelligent caching:
- Redis cache for validation results (30-day TTL)
- Batch processing for bulk validations
- Rate limiting to stay within free tiers
- Smart email normalization to reduce duplicates

## Key Takeaways

1. **Automation ROI is Real**: 85% reduction in manual work paid for system in 2 months

2. **Validation is Critical**: Proper email validation improved deliverability by 8x

3. **Segmentation Drives Results**: Personalized campaigns based on lead scores increased reply rates by 240%

4. **Event-Driven Architecture Scales**: Serverless approach handled 10x growth without code changes

5. **Monitoring is Essential**: Real-time metrics enabled quick issue resolution and optimization

## Client Testimonial

> "Bechara's automation system completely transformed our lead operations. What used to take our team days now happens in minutes, with better accuracy than we ever had manually. The 85% reduction in manual work has allowed us to scale without adding headcount. This system is the backbone of our growth."
>
> **— VP of Sales, Kalyxl**

## Technical Stack

**Backend**
- Node.js with TypeScript
- AWS Lambda for serverless compute
- AWS EventBridge for event orchestration
- PostgreSQL for relational data
- Redis for caching and rate limiting

**Integrations**
- ZeroBounce API for email validation
- SmartLead API for campaign management
- Clearbit API for company enrichment
- AWS SES for transactional emails

**Infrastructure**
- AWS Lambda + API Gateway
- RDS PostgreSQL (Multi-AZ)
- ElastiCache Redis
- CloudWatch for monitoring
- Terraform for IaC

**Monitoring & Observability**
- Datadog for APM
- Sentry for error tracking
- Custom Grafana dashboards
- PagerDuty for alerts
